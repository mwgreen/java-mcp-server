#!/usr/bin/env node

// eclipse-jdt-mcp: MCP bridge for Eclipse JDT Java analysis server
// Manages Java process lifecycle - spawns on demand, kills on exit

const { spawn } = require('child_process');
const readline = require('readline');
const path = require('path');
const crypto = require('crypto');

const JAR_PATH = path.join(__dirname, 'target', 'java-mcp-server-1.0.0.jar');

let javaProcess = null;
let javaReady = false;
let initializeRequest = null;
let requestBuffer = '';
let pendingRequests = [];

// Generate unique ID for this session (for multi-project support)
const sessionId = crypto.randomBytes(4).toString('hex');
console.error(`[eclipse-jdt-mcp] Session ${sessionId} starting`);

// Function to start Java backend
function startJavaBackend() {
  if (javaProcess) return;
  
  console.error(`[eclipse-jdt-mcp] Starting Java backend for session ${sessionId}`);
  
  javaProcess = spawn('java', [
    '-Xmx2G',
    '-Xms512M',
    `-Dsession.id=${sessionId}`,
    '-Dorg.slf4j.simpleLogger.logFile=System.err',
    '-Dorg.slf4j.simpleLogger.defaultLogLevel=error',
    '-jar',
    JAR_PATH
  ], {
    stdio: ['pipe', 'pipe', 'pipe']
  });
  
  // Handle Java stdout (responses)
  javaProcess.stdout.on('data', (data) => {
    requestBuffer += data.toString();
    const lines = requestBuffer.split('\n');
    requestBuffer = lines.pop(); // Keep incomplete line in buffer
    
    lines.forEach(line => {
      if (line.trim()) {
        try {
          const response = JSON.parse(line);
          console.log(JSON.stringify(response));
          
          // If this was the initialization response, mark Java as ready
          if (response.result && initializeRequest) {
            javaReady = true;
            initializeRequest = null;
            processPendingRequests();
          }
        } catch (e) {
          console.error(`[eclipse-jdt-mcp] Failed to parse Java response: ${e.message}`);
        }
      }
    });
  });
  
  // Handle Java stderr (logging)
  javaProcess.stderr.on('data', (data) => {
    // Log Java errors to stderr with prefix
    const lines = data.toString().split('\n');
    lines.forEach(line => {
      if (line.trim()) {
        console.error(`[Java] ${line}`);
      }
    });
  });
  
  // Handle Java process exit
  javaProcess.on('exit', (code, signal) => {
    console.error(`[eclipse-jdt-mcp] Java backend exited (code: ${code}, signal: ${signal})`);
    javaProcess = null;
    javaReady = false;
    
    // If Node is still running but Java died, restart might be needed
    if (code !== 0 && code !== null) {
      console.error(`[eclipse-jdt-mcp] Java backend crashed, will restart on next request`);
    }
  });
  
  javaProcess.on('error', (err) => {
    console.error(`[eclipse-jdt-mcp] Failed to start Java backend: ${err.message}`);
    javaProcess = null;
    javaReady = false;
  });
}

// Function to process pending requests
function processPendingRequests() {
  while (pendingRequests.length > 0 && javaReady) {
    const request = pendingRequests.shift();
    if (javaProcess && javaProcess.stdin.writable) {
      javaProcess.stdin.write(request + '\n');
    }
  }
}

// Set up stdin reader
const rl = readline.createInterface({
  input: process.stdin,
  terminal: false
});

rl.on('line', (line) => {
  if (!line.trim()) return;
  
  try {
    const request = JSON.parse(line);
    
    // Handle initialize specially
    if (request.method === 'initialize') {
      // Always respond immediately to Claude Code
      const response = {
        result: {
          protocolVersion: request.params?.protocolVersion || "2024-11-05",
          capabilities: { tools: {} },
          serverInfo: { 
            name: "Eclipse JDT Java Analyzer", 
            version: "1.0.0"
          }
        },
        jsonrpc: "2.0",
        id: request.id
      };
      console.log(JSON.stringify(response));
      
      // Start Java backend if not already running
      if (!javaProcess) {
        startJavaBackend();
      }
      
      // Forward to Java for actual initialization
      if (javaProcess && javaProcess.stdin.writable) {
        initializeRequest = line;
        javaProcess.stdin.write(line + '\n');
      }
      return;
    }
    
    // Handle notifications
    if (request.method === 'notifications/initialized') {
      // Forward to Java if ready
      if (javaProcess && javaProcess.stdin.writable) {
        javaProcess.stdin.write(line + '\n');
      }
      return; // No response needed
    }
    
    // For other requests, forward to Java or queue
    if (javaReady && javaProcess && javaProcess.stdin.writable) {
      javaProcess.stdin.write(line + '\n');
    } else if (!javaProcess) {
      // Java not started yet (shouldn't happen after initialize)
      const response = {
        error: {
          code: -32603,
          message: "Backend not initialized. Please call initialize first."
        },
        jsonrpc: "2.0",
        id: request.id
      };
      console.log(JSON.stringify(response));
    } else {
      // Java starting, queue the request
      pendingRequests.push(line);
      
      // Provide a temporary response for tools/list
      if (request.method === 'tools/list') {
        const response = {
          result: {
            tools: [{
              name: "initialize_project",
              description: "Initialize Java project analysis (backend starting...)"
            }]
          },
          jsonrpc: "2.0",
          id: request.id
        };
        console.log(JSON.stringify(response));
      }
    }
  } catch (e) {
    console.error(`[eclipse-jdt-mcp] Failed to parse request: ${e.message}`);
  }
});

// Clean shutdown - kill Java when Node exits
function cleanup() {
  console.error(`[eclipse-jdt-mcp] Shutting down session ${sessionId}`);
  
  if (javaProcess) {
    console.error(`[eclipse-jdt-mcp] Terminating Java backend`);
    javaProcess.kill('SIGTERM');
    
    // Give it 1 second to terminate gracefully
    setTimeout(() => {
      if (javaProcess) {
        console.error(`[eclipse-jdt-mcp] Force killing Java backend`);
        javaProcess.kill('SIGKILL');
      }
    }, 1000);
  }
  
  process.exit(0);
}

// Register cleanup handlers
process.on('SIGTERM', cleanup);
process.on('SIGINT', cleanup);
process.on('exit', () => {
  if (javaProcess) {
    javaProcess.kill('SIGKILL');
  }
});

// Handle stdin close
rl.on('close', () => {
  console.error(`[eclipse-jdt-mcp] Stdin closed, shutting down`);
  cleanup();
});

// Keep process alive
process.stdin.resume();