#!/usr/bin/env node

// eclipse-jdt-mcp: MCP bridge for Eclipse JDT Java analysis server
// Manages Java process lifecycle - spawns on demand, kills on exit

const { spawn } = require('child_process');
const readline = require('readline');
const path = require('path');
const crypto = require('crypto');

const JAR_PATH = path.join(__dirname, 'target', 'java-mcp-server-1.0.0.jar');

let javaProcess = null;
let javaReady = false;
let initializeId = null;  // Track the initialize request ID
let requestBuffer = '';
let pendingRequests = [];

// Generate unique ID for this session (for multi-project support)
const sessionId = crypto.randomBytes(4).toString('hex');
console.error(`[eclipse-jdt-mcp] Session ${sessionId} starting`);

// Function to start Java backend
function startJavaBackend() {
  if (javaProcess) return;
  
  console.error(`[eclipse-jdt-mcp] Starting Java backend for session ${sessionId}`);
  
  javaProcess = spawn('java', [
    '-Xmx2G',
    '-Xms512M',
    `-Dsession.id=${sessionId}`,
    '-Dorg.slf4j.simpleLogger.logFile=System.err',
    '-Dorg.slf4j.simpleLogger.defaultLogLevel=error',
    '-jar',
    JAR_PATH
  ], {
    stdio: ['pipe', 'pipe', 'pipe']
  });
  
  // Handle Java stdout (responses)
  javaProcess.stdout.on('data', (data) => {
    requestBuffer += data.toString();
    const lines = requestBuffer.split('\n');
    requestBuffer = lines.pop(); // Keep incomplete line in buffer
    
    lines.forEach(line => {
      if (line.trim()) {
        try {
          const response = JSON.parse(line);
          
          // Check if this is an initialization response from Java
          if (response.result && response.result.serverInfo && response.id === initializeId) {
            // Java has initialized, mark as ready
            javaReady = true;
            initializeId = null;
            processPendingRequests();
            // Don't forward this duplicate initialize response (we already sent one)
            return;
          }
          
          // Forward all other responses
          console.log(JSON.stringify(response));
        } catch (e) {
          console.error(`[eclipse-jdt-mcp] Failed to parse Java response: ${e.message}`);
        }
      }
    });
  });
  
  // Handle Java stderr (logging)
  javaProcess.stderr.on('data', (data) => {
    // Log Java errors to stderr with prefix
    const lines = data.toString().split('\n');
    lines.forEach(line => {
      if (line.trim()) {
        console.error(`[Java] ${line}`);
      }
    });
  });
  
  // Handle Java process exit
  javaProcess.on('exit', (code, signal) => {
    console.error(`[eclipse-jdt-mcp] Java backend exited (code: ${code}, signal: ${signal})`);
    javaProcess = null;
    javaReady = false;
    
    // If Node is still running but Java died, restart might be needed
    if (code !== 0 && code !== null) {
      console.error(`[eclipse-jdt-mcp] Java backend crashed, will restart on next request`);
    }
  });
  
  javaProcess.on('error', (err) => {
    console.error(`[eclipse-jdt-mcp] Failed to start Java backend: ${err.message}`);
    javaProcess = null;
    javaReady = false;
  });
}

// Function to process pending requests
function processPendingRequests() {
  while (pendingRequests.length > 0 && javaReady) {
    const request = pendingRequests.shift();
    if (javaProcess && javaProcess.stdin.writable) {
      javaProcess.stdin.write(request + '\n');
    }
  }
}

// Set up stdin reader
const rl = readline.createInterface({
  input: process.stdin,
  terminal: false
});

rl.on('line', (line) => {
  if (!line.trim()) return;
  
  try {
    const request = JSON.parse(line);
    
    // Handle initialize specially
    if (request.method === 'initialize') {
      // Start Java backend first if not already running
      if (!javaProcess) {
        startJavaBackend();
        
        // For the very first initialize, respond immediately but note we have tools
        const response = {
          result: {
            protocolVersion: request.params?.protocolVersion || "2024-11-05",
            capabilities: {
              tools: {
                listChanged: false  // We don't support dynamic tool list changes
              }
            },
            serverInfo: {
              name: "Eclipse JDT Java Analyzer",
              version: "1.0.0"
            }
          },
          jsonrpc: "2.0",
          id: request.id
        };
        console.log(JSON.stringify(response));
        
        // Still forward to Java for proper initialization
        initializeId = request.id;
        // Send immediately to Java (it needs this to become ready)
        // Java process was just started, give it a moment to be ready for stdin
        setTimeout(() => {
          if (javaProcess && javaProcess.stdin.writable) {
            javaProcess.stdin.write(line + '\n');
          }
        }, 100);
      } else if (javaReady) {
        // Java already running and ready, respond immediately
        const response = {
          result: {
            protocolVersion: request.params?.protocolVersion || "2024-11-05",
            capabilities: {
              tools: {
                listChanged: false  // We don't support dynamic tool list changes
              }
            },
            serverInfo: {
              name: "Eclipse JDT Java Analyzer",
              version: "1.0.0"
            }
          },
          jsonrpc: "2.0",
          id: request.id
        };
        console.log(JSON.stringify(response));
        
        // Don't forward to Java - we've already responded
      } else {
        // Java running but not ready yet, queue the request
        pendingRequests.push(line);
      }
      return;
    }
    
    // Handle notifications
    if (request.method === 'notifications/initialized') {
      // Forward to Java if ready
      if (javaReady && javaProcess && javaProcess.stdin.writable) {
        javaProcess.stdin.write(line + '\n');
      }
      // If Java not ready yet, ignore (we'll handle it when Java is ready)
      return; // No response needed
    }
    
    // Handle tools/list request - must be forwarded to Java
    if (request.method === 'tools/list') {
      
      // Ensure Java is started
      if (!javaProcess) {
        startJavaBackend();
      }
      
      // Forward to Java or queue
      if (javaReady && javaProcess && javaProcess.stdin.writable) {
        javaProcess.stdin.write(line + '\n');
      } else {
        // Java starting, queue the request
        pendingRequests.push(line);
      }
      return;
    }
    
    // For other requests, forward to Java or queue
    if (javaReady && javaProcess && javaProcess.stdin.writable) {
      javaProcess.stdin.write(line + '\n');
    } else if (!javaProcess) {
      // Java not started yet (shouldn't happen after initialize)
      const response = {
        error: {
          code: -32603,
          message: "Backend not initialized. Please call initialize first."
        },
        jsonrpc: "2.0",
        id: request.id
      };
      console.log(JSON.stringify(response));
    } else {
      // Java starting, queue the request
      pendingRequests.push(line);
    }
  } catch (e) {
    console.error(`[eclipse-jdt-mcp] Failed to parse request: ${e.message}`);
  }
});

// Clean shutdown - kill Java when Node exits
function cleanup() {
  console.error(`[eclipse-jdt-mcp] Shutting down session ${sessionId}`);
  
  if (javaProcess) {
    console.error(`[eclipse-jdt-mcp] Terminating Java backend`);
    javaProcess.kill('SIGTERM');
    
    // Give it 1 second to terminate gracefully
    setTimeout(() => {
      if (javaProcess) {
        console.error(`[eclipse-jdt-mcp] Force killing Java backend`);
        javaProcess.kill('SIGKILL');
      }
    }, 1000);
  }
  
  process.exit(0);
}

// Register cleanup handlers
process.on('SIGTERM', cleanup);
process.on('SIGINT', cleanup);
process.on('exit', () => {
  if (javaProcess) {
    javaProcess.kill('SIGKILL');
  }
});

// Handle stdin close
rl.on('close', () => {
  console.error(`[eclipse-jdt-mcp] Stdin closed, shutting down`);
  cleanup();
});

// Keep process alive
process.stdin.resume();